# 软工2复习

* 里氏替换原则

  * 里氏替换原则通俗的来讲就是：**子类可以扩展父类的功能，但不能改变父类原有的功能。**它包含以下4层含义：

    - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
    - 子类中可以增加自己特有的方法。
    - 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更**宽松**。
    - 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

    ​        看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？

    ​        后果就是：**你写的代码出问题的几率将会大大增加。**




# 软件工程

### 团队的特征

为了一致的目的、绩效标准、方法而共同承担责任且技能互补的少数人

- 团队成员需要具备共同的目标
- 共同承担责任
- 技能互补
- 团队内部要有一个明确的结构



### 团队结构

- 主程序员
- 民主
- 开放



### 团队建设

- 建立团队章程
- 持续成功
- 和谐沟通
- 避免团队杀手
  - 防范式管理
  - 官僚主义
  - 地理分散
  - 时间分割
  - 产品质量的降低
  - 虚假的最后期限
  - 小圈子控制



### 软件质量

- 质量模型
  - 功能性
  - 可靠性
  - 易用性
  - 效率
  - 可维护性
  - 可移植性

- 质量保障活动
  - 需求开发：需求评审、需求度量
  - 体系结构：体系结构评审、集成测试
  - 详细设计：详细设计评审、设计度量、集成测试
  - 实现：代码评审、代码度量、测试（测试驱动）
  - 测试：测试、测试度量

- 评审（review）
  - 规划阶段 planning
  - 总体部署阶段 overview
  - 准备阶段 preparation
  - 审查会议阶段 inspection meeting
  - 返工阶段 rework
  - 跟踪阶段 follow-up

- 质量度量

  - 测度 和 测量 measure & measurement
    - 定量指标
    - 代码行数
  - 度量 metric

  ### 配置管理活动

  - 标识配置项
  - 版本管理
  - 变更控制
  - 配置审计
  - 状态报告
  - 软件发布管理



### 配置项管理

- 基线
  - 经过评审的制品，可以作为进一步开发的基础
- 变更控制
  - 提交变更
  - 接受变更请求
  - 变更评估（生成变更表单）
  - 变更决策（变更委员会）
  - 执行变更
  - 验证变更
- 分支管理常见策略
  - 主分支 master
  - 开发分支 develop
  - 临时分支
    - 功能 feature
    - 预发布 release
    - 修补bug  fix bug


![](img/master.png)

![](img/feature.png)

### 项目管理的三架马车

- 产品经理
- 项目经理
- 技术经理



### 需求基础

- 需求
  - 就是用户的一种期望，软件系统通过满足用户的期望来解决用户的问题
  - IEEE的定义
    1. 用户为了解决问题或达到某些目标所需要的**条件或能力**
    2. 系统或系统部件为了满足**合同、标准、规范**或其他**正式文档**所规定的要求而需要具备的条件或能力
    3. 对1或2中的一个条件或一种能力的一种**文档化表述**
- 用例图四要素
  - 用例、参与者、关系、系统边界 
- 需求的层次性
  - 业务需求
    - 目标，解决方案与系统特性
  - 用户需求
    - 任务，问题域知识
  - 系统需求
    - 系统行为，需求分析模型
- 需求类型
  - 功能需求
  - 性能需求
    - 多好多快
  - 质量需求
    - 安全性
    - ​
  - 对外接口
  - 约束
  - 数据需求



### 需求分析模型

- 用例图
  - 进行目标分析与确定解决方向：高层解决方式
  - 寻找参与者
  - 寻找用例
  - 细化用例
- 概念类图
- 系统顺序图
- 状态图


### 候选类向概念类的转化

n 如果候选类的对象实例
¡ **既需要维持一定的状态， 又需要依据状态表现一定的行为**
n 确定为一个概念类
¡ 如只需要**维护状态**， 不需要表现行为
n 其他概念类的**属性**
¡ 不需要维护状态， 却需要表现行为
n 首先要重新审视需求是否有遗漏， 因为没有状态支持的对象无法表现行为
n 如果确定没有需求的遗漏， 就需要剔除该候选类， 并将行为转交给具备状态支持能力的其他概念类
¡ 既不需要维护状态， 又不需要表现行为
n 应该被完全剔除 

### 需求文档化的原因

软件开发本质上是这种类型的工作：

任务可以**分解为多个子任务**并分配给不同的人员，但是分解的子任务之间需要相互**沟通和交流**

软件开发的子任务与人员之间存在着**错综复杂**的关系，存在着大量的沟通与交流，所以软件系统的开发中需要编写多种不同类型的文档，每种文档都**针对项目中需要进行广泛交流**的内容。软件需求是项目中需要进行广泛交流的内容之一，所以需求开发阶段需要进行需求的文档化。



### 需求规格

* 书写要点
  * 易读（查询）
    * 有效使用引言、目录、索引等能够增强文档易读性的方法。
    * 使用系统化的方式组织内容信息，提供文档内容的可读性。



### 需求度量

* 功能点
  * ILF：Internal Logical File，用户能识别的由本系统维护（增，删，改）的数据对象，数据对象可以是业务数据、控制信息、或者业务规则数据。E-R图中的一个实体，系统的一个配置文件等都是ILF的实例。
  * EIF：External Interface File, 由别的系统维护的数据对象，但本系统需要参照。通常是别的系统的ILF。
  * EI：External Input，外部输入型事务处理，EI事务从系统外部输入数据到系统内部，这可能是用户通过画面输入，也可能是别的系统通过系统接口输入。输入包括业务数据，也包括按钮、Checkbox等控制数据。EI通常输入数据到ILF，一个ILF的维护通常包括增删改三个EI。
  * EO：External Output，输出型事务处理，如报表输出、画面初始化的输出。EO从系统内部输出数据到系统外部。EO输出的数据或者来自ILF或EIF，或者组合ILF/EIF的字段而来的新数据，或者通过算法计算而来的数据。通常确认Message或错误提示不算作独立的EO，但通知Mail之类的算作独立的EO。
  * EQ：External Inquiry，外部查询，从外部输入一些条件，系统返回一定的输出。简单的信息抽取。
* 功能点测度总数 = 求和（测度*因子）
* FP = 功能点测度总数 * (0.65+0.01*求和）




### 软件设计

* 定义
  * 为使一软件系统满足**规定的需求**而定义系统或部件的**体系结构、部件、接口**和其他特征的过程；
  * 设计过程的结果。
* 设计的核心：复杂度控制
  * 抽象 和 分解 
* **设计的三个层次**
  * 高层设计：基于反映软件高层抽象的构件层次，描述系统的**高层结构、关注点和设计决策**
  * 中层设计：更加关注组成构件的模块的划分、导入/导出、**过程**之间的**调用**关系或者**类**之间的**协作**
  * 低层设计：深入模块和类的**内部**，关注具体的数据结构、算法、类型和控制结构等
* 区分外部表现与内部结构
  * 外部：简洁
  * 内部：坚固
* 部件与连接件
  * 部件承载了计算（功能）和状态（数据）
  * 连接件承载了部件间的关系
* 体系结构风格
  * 主程序与子程序
    * 优点
      * 流程清晰，易于理解
      * 强控制性，比其他风格更能控制程序的”正确性“
    * 缺点
      * 程序调用是一种强耦合的连接方式，非常依赖交互方的接口，使得系统难以**修改和复用**
      * 程序调用限制了各部件之间的**数据交互**，可能使用隐含的共享数据，产生不必要的**公共耦合**
  * 面向对象风格
    * 数据表示和相关操作封装在抽象数据类型
    * 优点
      * 内部实现的可修改性
      * 易开发、易理解、易复用
    * 缺点
      * 接口的耦合性
      * 标识的耦合性
      * 副作用
  * 分层风格
    * 系统组织成层，其中每一层：
      * 给上一层提供服务
      * 作为下一层的客户端
    * 优点
      * 设计机制清晰，易于理解
      * 支持并行开发
      * 更好的可复用性与内部可修改性
    * 缺点
      * 交互协议难以修改
      * 性能损失
      * 难以确定层次数量和粒度
  * MVC风格
    * **Model**子系统被设计成**不依赖**任何View或Controller子系统
    * 它们状态的改变会传播到View子系统
    * 优点
      * 易开发性
      * 视图和控制的可修改性
      * 适宜于网络系统开发的特征
    * 缺点
      * 复杂性
      * 模型修改困难
* 体系结构构建过程
  * 分析关键**需求**和限制条件；
  * 通过选择**体系结构风格**，确定顶层架构；
  * **实现**功能需求的逻辑映射；
  * 通过构件的逐层设计从**逻辑视角向物理视角**的转化；
  * 添加**辅助**构件；
  * **完善**构件之间**接口**的定义；
  * **完善数据**的定义。
  * 迭代过程3-7
* 包原则
  * 最高原则:**包与包之间不能有重复和冗余**
  * 复用发布等价原则(REP)
    * 利用的单元是发布的单元
    * 一个包中的类应该形成一个可复用和可发布的模块
  * 共同封闭原则(CCP)
    * 一起改变的类属于一个整体
    * 包闭合了预期的变化
  * 共同复用原则(CRP)
    * 包中的类应一起被复用
  * 无环依赖原则(ACP)
    * 依赖环的解决方案
      * 分解包
      * 抽象依赖
  * 稳定依赖原则(SDP)
    * 依赖应指向稳定的包
  * 稳定抽象原则
    * **稳定包应是抽象包、不稳定包应是具体包**
    * 对象的创建如何 解决
      * Spring方案：在程序启动时,第三方(初始化程序)一次性创建完成对象实例并set给上一层
      * Factory方案
* CCP和CRP的权衡
  * CCP 和CRP原则相互排斥，例如它们不能同时被满足
  * CRP使得**复用者**的工作更简单，而CCP使**维护者**的生活更简单
  * CCP努力让包尽可能大，而CRP设法让包很小
  * 项目的早期，架构师可能以CCP为主导来辅助开发和维护。架构稳定后，架构师可能重构包结构，为了外部复用者而最大化CRP.



### 人机交互

* 可用性
  * 是人机交互的好坏的一个定量的评价，是一个多维度的质量属性，包括 易学性、效率、易记性、出错率、主观满意度
* 精神模型
  * 隐喻设计
* 差异性
  * 用户群体：新手用户、专家用户、熟练用户
* 交互性
  * 导航、反馈
* 协作式设计
  * 就需要让计算机更多地**适应人**的因素，这也是人机交互设计以用户为中心的根本原因
* 设计原则
  * 简洁设计
    * 7+-2原则
    * 图片比文字更简洁和清晰
  * 一致性设计
  * 低出错率设计
    * 容忍用户出错
    * 避免用户犯错
    * 提供简洁、有建设性、具体的指导
      * 出错信息遵循：
        * 清晰的语言
        * 精练准确的语言
        * 有建设性的帮助
        * 友好，不威胁和责备用户
    * 错误恢复和故障解决手册
  * 易记性设计
    * 减少短期记忆负担。
    * 使用逐层递进的方式展示信息
    * 使用直观的快捷方式。重新认知比记忆更容易。
    * 设置有意义的缺省值，可以帮助用户减少记忆负担。



### 详细设计

* 出发点
  * 需求开发的结果 和 软件体系结构的结果 
* 结构化设计过程
  * 寻找输入、输出最高抽象点
  * 划分
  * 为模块去寻找最高抽象点
* 面向对象设计过程
  * 设计模型建立 
    * 通过职责建立静态设计模型
      * **抽象类的职责**
        * 属性职责和方法职责
      * 抽象类之间的关系
        * 依赖<关联<聚合<组合<继承
      * 添加辅助类
    * 通过协作建立动态设计模型
      * **抽象类之间的协作**：顺序图和状态图
      * 明确对象的创建
      * 选择合适的控制风格：集中式、委托式、分散式
  * Mock Object
    * 为协作设计的    本身逻辑简单    的类似于stub的类



### 模块化与信息隐藏

* 耦合
  * 定义：两个模块之间关系的复杂程度
  * 分类（由高到低）
    * 内容：修改内部代码数据
    * 公共：全局变量 
    * 重复：代码复制
    * 控制：Connections that pass data and control elements
    * 印记：共享一个数据结构，却只用了其中一部分 ¡Connections that pass data **more**
      than necessary
    * 数据：参数传递
  * 耦合的处理？
    * 分层风格：仅程序调用与简单数据传递
    * 包设计：消除重复
    * 分包：接口最小化
    * 创建对象：不增加新的耦合
    * 控制者模式：解除View与Logical的直接耦合
* 内聚
  * 定义：一个模块内部的联系的紧密性
  * 分类（从低到高）
    * 偶然
    * 逻辑：一系列相关的操作（乘坐汽车、乘坐飞机。。。）**Binding by logical similarity**
    * 时间：一系列与时间有关的操作 **Binding by the same time**
    * 过程：一系列与步骤顺序有关的操作 **Binding by the same problem** (Output
      of one element is input to the next)
    * 通信：在过程内聚上，在相同的数据上操作（查找书的作者、查找书的名字）**Binding by the same data**
    * 功能：只执行一个操作或达到一个单一的目的 **Binding by the same goal**
    * 信息：在相同的数据结构上完成的一系列操作，各自独立；用实现抽象数据结构；（栈）
    * **偶然性内聚**：组件的部件是不相关的，只是简单地绑定成单个组件。 
      不足：程序的可读性和复用性差
    * **逻辑性内聚**：把相似的功能（类如输入，错误处理）放在一块，通过传递一个参数来决定是哪一个功能来执行。 
      不足：接口可读性差，代码复用性低
    * **时间性内聚**：所有的语句在同一时刻被激活，就像电脑关机的时候，其他所有的程序都要被关闭。 
      不足：模块内的关联不高，而与模块外的关联却很高，所以在维护的时候工作量会 比较大。
    * 过程性内聚：简单地把一系列过程关联在一起 
      不足：代码的复用性比较差
    * **通信性内聚**：操作相同的输入数据或者输出相同的输出数据，可能产生多种功能。 
      不足：代码的复用性不高
    * **顺序内聚**：从一个部分的输出作为另一部分的输入。可能包含几个功能或部分不同的功能。 
      不足：代码的复用性不高
    * **信息聚合**：执行多个功能，每个函数都有自己的入口点，每个函数都有独立的代码，所有的功能都在相同的数据结构上执行。不同于逻辑衔接，因为功能没有交织在一起。
    * **功能内聚**：每一部分都需要执行一个单一的功能。例如，计算平方根或排序数组。通常在其他情况下可重复使用。维修容易。 
  * 内聚处理？
    * 分层
      * 层间职责分配高内聚
      * 层内分包高内聚
    * 信息专家模式（要求状态与方法紧密联系）
    * 控制器与委托式控制风格（控制器不可避免出现时间内聚，对外委托）
* 信息与隐藏
  * 主要秘密：来自于需求
  * 次要秘密：根源于实现
  * 角色
  * 提供的接口



### 面向对象方法下的模块化

* 访问耦合
  * 类别（耦合程度由高到低）
    * 隐式访问：Cascading message
    * 实现中访问 ：B的引用是A的局部变量
    * 成员变量访问 ：B的引用是A的成员变量
    * 参数变量访问  ：B的引用是A的方法的参数变量
    * 无访问
* 继承耦合
  * 修改(modification)
  * 精化(refinement)
  * 扩展(extension)
  * 无(nil)
* 内聚
  * 方法和属性是否一致
  * 属性之间是否体现 一个职责
  * 属性之间是否可抽象
* 提高内聚的方法
  * 集中信息与行为
  * Single Responsibility Principle(SRP)


* 降低耦合的设计原则
  * 1: 《Global Variables Consider Harmful》
  * 2: 《To be Explicit》
  * 3: 《Do not Repeat》
  * 4: Programming to Interface (Design by Contract)
  * 5: The Law of Demeter
  * 6: Interface Segregation Principle(ISP)
    * Use several client-specific interfaces 
  * 7: Liskov Substitution Principle (LSP)
    * Derived class services should **require no more and promise no less** 
  * 8: Favor Composition Over Inheritance
    * Use inherit for polymorphism
    * Use delegate not inherit to reuse code
* 度量
  * 耦合的度量
    * 方法调用耦合
      * Coupling Between Object
    * 访问耦合
      * Data Abstraction Coupling
    * 继承
      * Number Of Children
      * Depth of the Inheritance Tree

### 面向对象的信息隐藏

* 封装
  * 含义1：数据与行为集中在一起
  * 含义2：接口与实现分离
* 封装实现细节
  * **封装数据和行为**
    * 访问权限
    * 不要暴露 存储数据 和 推导数据 之间的区别（getXXX & calXXX)
  * 封装内部结构
    * 迭代器模式
  * **封装其他对象的引用**
    * 委托
  * 封装类型信息
    * LSP
  * 封装潜在变更
* 为变更而设计
  * 开闭原则（OCP)
  * 依赖倒置原则 Dependency Inversion Principle
    * I. 高层模块不应依赖底层模块，两者都应依赖抽象
    * II. 抽象不应依赖细节，细节应依赖抽象



### 设计模式

* 实现的可修改性
  * 实现和接口分离
    * 通过接口和实现该接口的类完成接口与实现的分离
    * 通过子类继承父类，将父类的接口和子类的实现相分离

### 软件构造

* 包含的活动：
  * 详细设计、编程、测试、调试、代码评审、集成与构建、构造管理
* 名词解释
  * 重构：修改软件系统的严谨方法，它在不改变代码外部表现的情况下改进其内部结构。
  * 测试驱动开发：又称为测试优先的开发。它要求程序员在编写一段代码之前，优先完成该段代码的测试代码。
  * 结对编程：两个程序员挨着坐在一起，共同协作进行软件构造。掌握键盘的人称为driver，负责输入代码。边上的程序员称为observer，负责评审

### 代码设计

* 格式
* 易维护代码
  * 小型任务
  * 复杂决策
    * 使用新的布尔变量简化复杂决策
    * 使用有意义的名称封闭复杂决策
      * isValid(xxx)
    * 表驱动编程 
    * 数据使用（变量）
    * 明确依赖关系
      * @see 注解模糊依赖
* 可靠的代码
  * 契约式设计
    * 检查前置后置条件
    * 异常方式
      * 测试驱动开发是一种异常方式的契约式设计 
    * 断言方式
  * 防御式编程
    * 将所有与外界的交互都纳入防御范围



### 软件测试

* 基于规格的技术——黑盒测试
  * 等价类划分
  * 边界值分析
* 基于代码的技术——白盒测试
  * 语句覆盖：每个语句至少执行一次
  * 条件覆盖：让每个判断的结果都至少满足一次
  * 路径覆盖：每条路径至少执行一次



### 软件维护与演化

* 变更情景
  * 问题发生了变化、环境发生了变化、软件产品中存在缺陷


* 类型分为
  * 完善性维护、适应性维护、修正性维护、预防性维护
* 维护高代价原因
  * 变更的频繁性 和 维护的困难性
* 开发可维护的软件
  * 考虑软件的可变更性
    * 分析需求的易变性
    * 为变更进行设计
  * 为降低维护困难而开发
    * 编写详细的技术文档并保持及时更新
    * 保证代码的可读性
    * 维护需求跟踪链
    * 维护回归测试基线
* 维护的过程
  * 问题/修改的标识 & 分类分析 & 设计 & 实现 & 回归/系统测试 & 验收测试 & 移交





* **软件演化生命周期模型**
  * 初始开发
  * 演化
  * 服务
  * 逐步淘汰
  * 停止
* 逆向工程
  * 分析⽬标系统，标识系统的部件及其交互关系，并且使⽤其它形式或者更⾼层的抽象创建系统表现的过程 
  * 理解软件
* 再工程
  * 检查和改造⼀个⽬标系统，⽤新的模式式及其实现复原该⽬标系统。
  * 修改软件